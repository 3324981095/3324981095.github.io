<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夜笙</title>
  
  
  <link href="https://www.nightshone.top/atom.xml" rel="self"/>
  
  <link href="https://www.nightshone.top/"/>
  <updated>2025-04-16T12:56:52.942Z</updated>
  <id>https://www.nightshone.top/</id>
  
  <author>
    <name>nightshone🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>类与对象--对象之舞，类之华章，共绘C++之美</title>
    <link href="https://www.nightshone.top/posts/3d6e6861.html"/>
    <id>https://www.nightshone.top/posts/3d6e6861.html</id>
    <published>2025-04-15T09:05:07.730Z</published>
    <updated>2025-04-16T12:56:52.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、类的定义"><a href="#一、类的定义" class="headerlink" title="一、类的定义"></a>一、类的定义</h1><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClaeeName</span></span></span><br><span class="line"><span class="class"></span>&#123;        </span><br><span class="line"></span><br><span class="line">    //类体</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述代码中，class为定义类的关键字，ClassName为类名，括号里面的是主体</p><blockquote><p>在c++中有六个默认成员函数：</p><p>1、构造函数  2、析构函数   3、拷贝构造函数  4、拷贝赋值重载   5、取地址重载   6、const取地址重载。最重要的是前4个。c++11新增了两个：移动构造函数和移动赋值运算符重载。</p></blockquote><h1 id="二、构造函数"><a href="#二、构造函数" class="headerlink" title="二、构造函数"></a>二、构造函数</h1><p>2.1构造函数是一个特殊的成员函数，名字与类名相同,创建类类型对象时由编译器自动调用，以保证每个数据成员都有 一个合适的初始值，并且在对象整个生命周期内只调用一次</p><blockquote><p>   特点：</p><ul><li>名称与类名相同: 构造函数的名称必须与类名完全相同。</li><li>可以重载: C++ 允许定义多个构造函数，只要它们的参数列表不同（例如参数的类型或数量）。</li><li>默认构造函数:如果没有定义任何构造函数，编译器会提供一个默认的构造函数</li><li>没有返回类型: 构造函数不返回任何类型，也不应该定义返回类型。</li></ul></blockquote><p>示例代码：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> <span class="built_in">day</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="built_in">month</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="built_in">year</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">// 默认构造函数  </span></span><br><span class="line">    <span class="title function_">Date</span>() : <span class="built_in">day</span>(<span class="number">1</span>), <span class="built_in">month</span>(<span class="number">1</span>), <span class="built_in">year</span>(<span class="number">2000</span>) &#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;默认构造函数被调用，日期为 &quot;</span> &lt;&lt; <span class="built_in">day</span> &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in">month</span> &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in">year</span> &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的构造函数  </span></span><br><span class="line">    <span class="title function_">Date</span>(<span class="type">int</span> d, <span class="type">int</span> m, <span class="type">int</span> y) : <span class="built_in">day</span>(d), <span class="built_in">month</span>(m), <span class="built_in">year</span>(y) &#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;带参数的构造函数被调用，日期为 &quot;</span> &lt;&lt; <span class="built_in">day</span> &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in">month</span> &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in">year</span> &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日期方法  </span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span>() <span class="keyword">const</span> &#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;日期为 &quot;</span> &lt;&lt; <span class="built_in">day</span> &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in">month</span> &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in">year</span> &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span>() &#123;  </span><br><span class="line">    Date date1; <span class="comment">// 调用默认构造函数  </span></span><br><span class="line">    Date <span class="title function_">date2</span>(<span class="number">21</span>, <span class="number">11</span>, <span class="number">2024</span>); <span class="comment">// 调用带参数构造函数  </span></span><br><span class="line">    date1.<span class="property">display</span>();  </span><br><span class="line">    date2.<span class="property">display</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述代码中：</p><ul><li>Date 类中定义了两个构造函数：一个默认构造函数和一个带参数的构造函数。</li><li>Date date1; 使用默认构造函数初始化，日期为 1/1/2000。</li><li>Date date2(21, 11, 2024); 使用带参数构造函数初始化，日期为 21/11/2024。</li><li>display 方法用于输出日期信息</li></ul><hr><h1 id="三、析构函数"><a href="#三、析构函数" class="headerlink" title="三、析构函数"></a>三、析构函数</h1><p>定义：析构函数是一种特殊的成员函数，在对象的生命周期结束时自动调用，用于释放对象占用的资源。</p><blockquote><p>特点：</p><ul><li>名称与类名相同，前面加波浪号（~）: 例如 ~Point()。</li><li>没有参数和返回值: 析构函数不能带参数，也不返回值。</li><li>不能重载: 每个类只能有一个析构函数。</li><li>调用顺序: 析构函数的调用顺序是与对象构造顺序相反的。</li></ul></blockquote><p>示例代码：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Event</span> &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="built_in">string</span> name;  </span><br><span class="line">    Date date; <span class="comment">// 使用日期类作为成员  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">// 构造函数  </span></span><br><span class="line">    Event(<span class="keyword">const</span> <span class="built_in">string</span>&amp; eventName, <span class="built_in">int</span> d, <span class="built_in">int</span> m, <span class="built_in">int</span> y) : name(eventName), date(d, m, y) &#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造函数：事件 \&quot;&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\&quot; 在 &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; 被创建&quot;</span> &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数  </span></span><br><span class="line">    ~Event() &#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数：事件 \&quot;&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\&quot; 被销毁&quot;</span> &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印事件信息  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span>() <span class="keyword">const</span></span> &#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;事件名称: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, 日期: &quot;</span>;  </span><br><span class="line">        date.display();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span> &#123;  </span><br><span class="line">    <span class="function">Event <span class="title">event</span>(<span class="params"><span class="string">&quot;生日派对&quot;</span>, <span class="number">21</span>, <span class="number">11</span>, <span class="number">2024</span></span>)</span>; <span class="comment">// 创建事件  </span></span><br><span class="line">    <span class="keyword">event</span>.display();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 在此处 event 对象被销毁，析构函数会被调用  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码解析：<br>Event 类包含一个字符串成员 name 和一个 Date 类型的成员 date。<br>在构造函数中，初始化事件名称和日期，当 Event 对象创建时，构造函数被调用。<br>当 Event 对象超出作用域时，析构函数被自动调用，输出事件销毁的信息</p><hr><h1 id="四、拷贝构造函数"><a href="#四、拷贝构造函数" class="headerlink" title="四、拷贝构造函数"></a>四、拷贝构造函数</h1><p>定义: 拷贝构造函数是一种特殊的构造函数，用于通过复制现有对象来创建新对象。当对象通过传值方式传递或者被返回时，会调用拷贝构造函数。其签名为 ClassName(const ClassName &amp;obj)，它需要一个同类型对象的引用作为参数。</p><blockquote><p>拷贝构造函数在以下情况下被调用：</p><ul><li>当一个对象被初始化为另一个对象。</li><li>当对象作为参数传递给函数（使用值传递）。</li><li>当一个对象从一个函数返回时</li></ul></blockquote><ul><li>浅拷贝：只复制指针的值，如果两个对象共享同一内存区域，可能导致内存管理问题。C++ 默认生成的拷贝构造函数是浅拷贝。</li><li>深拷贝：复制对象指向的实际资源，确保每个对象都有独立的内存。这需要手动实现拷贝构造函数。</li></ul><p>示例代码如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> <span class="built_in">day</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="built_in">month</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="built_in">year</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">// 默认构造函数  </span></span><br><span class="line">    <span class="title function_">Date</span>() : <span class="built_in">day</span>(<span class="number">1</span>), <span class="built_in">month</span>(<span class="number">1</span>), <span class="built_in">year</span>(<span class="number">2000</span>) &#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数构造函数  </span></span><br><span class="line">    <span class="title function_">Date</span>(<span class="type">int</span> d, <span class="type">int</span> m, <span class="type">int</span> y) : <span class="built_in">day</span>(d), <span class="built_in">month</span>(m), <span class="built_in">year</span>(y) &#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数  </span></span><br><span class="line">    <span class="title function_">Date</span>(<span class="keyword">const</span> Date&amp; other) : <span class="built_in">day</span>(other.<span class="property">day</span>), <span class="built_in">month</span>(other.<span class="property">month</span>), <span class="built_in">year</span>(other.<span class="property">year</span>) &#123;  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数被调用，日期为 &quot;</span> &lt;&lt; <span class="built_in">day</span> &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in">month</span> &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in">year</span> &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日期  </span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span>() <span class="keyword">const</span> &#123;  </span><br><span class="line">        cout &lt;&lt; <span class="built_in">day</span> &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in">month</span> &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in">year</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Data <span class="title function_">d1</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2025</span>);</span><br><span class="line">    d1.<span class="property">display</span>();</span><br><span class="line">    Data d2=d1; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    d2.<span class="property">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码讲解：</p><ul><li>Date 类中定义了拷贝构造函数，用于深拷贝日期对象。</li><li>在 main 函数中，d1用于创建了个日期，Data d2=d1,触发拷贝构造函数，d1,d2各自拥有不同的内存区域</li></ul><hr><h1 id="五、运算符重载"><a href="#五、运算符重载" class="headerlink" title="五、运算符重载"></a>五、运算符重载</h1><h2 id="5-1为什么需要赋值运算符重载"><a href="#5-1为什么需要赋值运算符重载" class="headerlink" title="5.1为什么需要赋值运算符重载"></a>5.1为什么需要赋值运算符重载</h2><p>在类中定义动态内存（如指针数组）的对象时，使用默认的赋值运算符将导致两个对象指向同一块内存区域。当其中一个对象被修改或销毁时，另一个对象可能会出现错误或崩溃。通过重载赋值运算符，我们可以实现深拷贝，从而避免这些问题。</p><h2 id="5-2赋值运算符重载的实现"><a href="#5-2赋值运算符重载的实现" class="headerlink" title="5.2赋值运算符重载的实现"></a>5.2赋值运算符重载的实现</h2><p>代码如下：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> <span class="built_in">day</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="built_in">month</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="built_in">year</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">// 默认构造函数  </span></span><br><span class="line">    <span class="title function_">Date</span>() : <span class="built_in">day</span>(<span class="number">1</span>), <span class="built_in">month</span>(<span class="number">1</span>), <span class="built_in">year</span>(<span class="number">2000</span>) &#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的构造函数  </span></span><br><span class="line">    <span class="title function_">Date</span>(<span class="type">int</span> d, <span class="type">int</span> m, <span class="type">int</span> y) : <span class="built_in">day</span>(d), <span class="built_in">month</span>(m), <span class="built_in">year</span>(y) &#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值运算符重载  </span></span><br><span class="line">    Date&amp; operator=(<span class="keyword">const</span> Date&amp; other) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">this</span> != &amp;other) &#123; <span class="comment">// 防止自我赋值  </span></span><br><span class="line">            <span class="built_in">day</span> = other.<span class="property">day</span>;  </span><br><span class="line">            <span class="built_in">month</span> = other.<span class="property">month</span>;  </span><br><span class="line">            <span class="built_in">year</span> = other.<span class="property">year</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> *<span class="variable">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日期  </span></span><br><span class="line">    <span class="keyword">void</span> <span class="built_in">print</span>() <span class="keyword">const</span> &#123;  </span><br><span class="line">        cout &lt;&lt; <span class="built_in">day</span> &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in">month</span> &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in">year</span> &lt;&lt; endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>我们主要对Date&amp; operator=(const Date&amp; other) 这块代码讲解：</p><ul><li>返回类型：返回类型为 Date&amp;，表示我们返回当前对象的引用，以支持链式赋值操作（例如：a = b = c;）。</li><li>参数：接受一个 const Date&amp; 参数，表示我们要赋值给当前对象的对象。</li><li>自我赋值检查：if (this != &amp;other) 是为了检查当前对象是否与被赋值的对象相同（即自我赋值）。如果它们相同，我们就不需要执行任何操作。</li><li>字段复制：如果不是自我赋值，就将 other 对象的成员变量逐个复制到当前对象。</li><li>返回当前对象：最后，返回 *this，允许链式赋值。</li></ul><hr><h2 id="5-3测试实现"><a href="#5-3测试实现" class="headerlink" title="5.3测试实现"></a>5.3测试实现</h2><p>我们在main函数中实现这块代码：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span> &#123;  </span><br><span class="line">    <span class="function">Date <span class="title">date1</span>(<span class="params"><span class="number">21</span>, <span class="number">11</span>, <span class="number">2024</span></span>)</span>; <span class="comment">// 创建第一个日期对象  </span></span><br><span class="line">    Date date2;              <span class="comment">// 创建第二个日期对象  </span></span><br><span class="line">    date2 = date1;          <span class="comment">// 使用赋值运算符重载  </span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;date1: &quot;</span>;  </span><br><span class="line">    date1.print();           <span class="comment">// 输出 date1 的值  </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;date2: &quot;</span>;  </span><br><span class="line">    date2.print();           <span class="comment">// 输出 date2 的值  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>1、创建对象：Date date1(21, 11, 2024); 创建一个日期为 2024 年 11 月 21 日的对象。<br>2、赋值操作：date2 = date1; 调用重载的赋值运算符，将 date1 的值赋给 date2。<br>3、输出结果：使用 print() 方法输出两个日期对象的值。<br>注意：</p><blockquote><p>避免自我赋值：在实现赋值运算符时，总是要检查自我赋值，以防止无意中导致错误。<br>返回当前对象的引用：这样可以使赋值操作支持链式调用。<br>深拷贝与浅拷贝：在处理动态内存时，请确保使用深拷贝，避免多个对象指向同一块内存。</p></blockquote><h1 id="六、友元"><a href="#六、友元" class="headerlink" title="六、友元"></a>六、友元</h1><h2 id="6-1友元的定义"><a href="#6-1友元的定义" class="headerlink" title="6.1友元的定义"></a>6.1友元的定义</h2><blockquote><p><font color=#0099ff size=3 face=“黑体”>友元函数</font>：一个被特定类声明为友元的外部函数，可以访问该类的私有和保护成员，但它并不是类的成员函数</p><p><font color=#0099ff size=3 face=“黑体”>友元类</font>：某个类的所有成员函数都可以是另一个类的友元，允许访问该类的私有和受保护成员</p></blockquote><h3 id="6-1-2声明和实现"><a href="#6-1-2声明和实现" class="headerlink" title="6.1.2声明和实现"></a>6.1.2声明和实现</h3><p>友元函数在类内部声明，外部实现。下面是一个简单的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> data;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> d) : <span class="built_in">data</span>(d) &#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明友元函数  </span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span>;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数实现  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span> </span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Data: &quot;</span> &lt;&lt; obj.data &lt;&lt; endl; <span class="comment">// 可以访问私有成员  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2友元的用途"><a href="#6-2友元的用途" class="headerlink" title="6.2友元的用途"></a>6.2友元的用途</h2><p>1、运算符重载：在重载运算符时，友元函数可以直接访问对象的私有数据。<br>2、类间协作：当一个类需要访问另一个类的内部数据时，通过友元关系可以实现这种需求。<br>3、提高性能：友元函数可以减少对 getter/setter 方法的调用，直接访问数据从而提高性能。</p><hr><h2 id="6-3友元类"><a href="#6-3友元类" class="headerlink" title="6.3友元类"></a>6.3友元类</h2><blockquote><p>定义<br>友元函数是一个被声明为某个类的友元的非成员函数。友元函数可以直接访问该类的私有和保护成员，即使它不是该类的一个成员。<br>实现</p></blockquote><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;  </span></span><br><span class="line">using namespace std;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span>; // 前向声明  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoxPrinter</span> </span>&#123;  </span><br><span class="line">public:  </span><br><span class="line">    void printBoxDetails(const Box&amp; box); <span class="regexp">//</span> 成员函数声明  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;  </span><br><span class="line">private:  </span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">length</span>;  </span><br><span class="line"></span><br><span class="line">public:  </span><br><span class="line">    Box(<span class="keyword">int</span> l) : <span class="keyword">length</span>(l) &#123;&#125;  </span><br><span class="line"></span><br><span class="line">    // 将 BoxPrinter 声明为友元类  </span><br><span class="line">    friend <span class="class"><span class="keyword">class</span> <span class="title">BoxPrinter</span></span>;   </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 友元类的成员函数实现  </span><br><span class="line">void BoxPrinter::printBoxDetails(const Box&amp; box) &#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Box length: &quot;</span> &lt;&lt; box.length &lt;&lt; endl; <span class="regexp">//</span> 访问私有成员  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;  </span><br><span class="line">    Box box(<span class="number">10</span>);  </span><br><span class="line">    BoxPrinter printer;  </span><br><span class="line"></span><br><span class="line">    printer.printBoxDetails(box); <span class="regexp">//</span> 使用友元类输出 Box 的长度  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>代码详解：</p><blockquote><p>类前向声明：使用 class Box; 声明 Box 类，以便在 BoxPrinter 中引用。<br>友元类：BoxPrinter 类的成员函数 printBoxDetails 被声明为友元，使其能够访问 Box 的私有成员 length。<br>友元类功能：BoxPrinter::printBoxDetails 函数实现打印 Box 对象的私有成员 length。<br>输出：在 main 函数中，创建 Box 和 BoxPrinter 对象，通过友元类方法打印盒子的长度。</p></blockquote><h3 id="6-3-2-友元类用途"><a href="#6-3-2-友元类用途" class="headerlink" title="6.3.2 友元类用途"></a>6.3.2 友元类用途</h3><blockquote><ul><li>信息隐藏与协作：友元类通过允许访问来实现必要的协作，同时保持其他类的封装性。</li><li>用于复杂数据类型：在创建复杂的数据结构时，友元类允许对数据的直接操作，而不让外部代码访问。</li><li>模块化设计：它们能够促进模块间的通信，而不损害数据的隐私。</li></ul></blockquote><h2 id="6-4友元函数与友元类的注意事项"><a href="#6-4友元函数与友元类的注意事项" class="headerlink" title="6.4友元函数与友元类的注意事项"></a>6.4友元函数与友元类的注意事项</h2><blockquote><p>Friendship is not inherited：友元关系不会被继承。子类不自动成为友元类，需显式声明。<br>易于使用但需谨慎：友元函数和类能够直接访问私有成员，过度使用可能会导致对象的封装性丧失。<br>设计时考虑：在设计类和友元关系时，应考虑未来可能的维护和扩展。</p></blockquote><p>总结</p><blockquote><p>过对构造函数、析构函数和拷贝构造函数的学习，我们可以更加灵活和高效地管理 C++ 对象的生命周期。掌握这些基础对于开发复杂的 C++<br>应用程序是至关重要的。</p><ul><li>构造函数用于初始化对象。</li><li>析构函数用于清理资源，防止内存泄漏。</li><li>拷贝构造函数确保对象之间的独立性，避免共享某些资源导致的问题。<br>友元函数和友元类在 C++ 中为设计灵活而强大的类提供了一个便捷的方式。它们允许我们在不改变封装性的情况下，控制对类内部数据的访问。然而，应谨慎使用友元关系，以免导致程序复杂化或不小心破坏了封装性。</li></ul><h2 id="希望这篇博客能够帮助你更深入理解-C-中的这些关键概念。如果你有任何问题或者想讨论的内容，请随时留言！"><a href="#希望这篇博客能够帮助你更深入理解-C-中的这些关键概念。如果你有任何问题或者想讨论的内容，请随时留言！" class="headerlink" title="希望这篇博客能够帮助你更深入理解 C++ 中的这些关键概念。如果你有任何问题或者想讨论的内容，请随时留言！"></a>希望这篇博客能够帮助你更深入理解 C++ 中的这些关键概念。如果你有任何问题或者想讨论的内容，请随时留言！</h2></blockquote>]]></content>
    
    
    <summary type="html">本期带来C++类与对象相关笔记</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>第一篇</title>
    <link href="https://www.nightshone.top/posts/73626faf.html"/>
    <id>https://www.nightshone.top/posts/73626faf.html</id>
    <published>2025-04-14T04:39:33.202Z</published>
    <updated>2025-04-16T12:58:08.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、开始"><a href="#一、开始" class="headerlink" title="一、开始"></a>一、开始</h1><p>当你看到这一篇的时候，说明nightshone博客网站基本搭建完成，具体一些细则还在改，因为涉及到一些前端知识，所以还在加急修改….</p><p>看到这里  说明已经修改一半了<br>关于我建站初衷就是 学习记录 看别人有个自己的网站很酷 所以很感兴趣，就学了学，目前还在学习中，前端涉及的还挺多，也挺有意思的。<br>搭建过程并不顺利，一开始部署错误 显示不了效果，最终只能重新来，还好有个小孩哥指导</p><p>![<a href="https://cdn.szyd.fun/2025/04/16/67ff936d564dd.png">https://cdn.szyd.fun/2025/04/16/67ff936d564dd.png</a>]</p><h1 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h1>]]></content>
    
    
    <summary type="html">本期带来搭建历程</summary>
    
    
    
    
  </entry>
  
</feed>
